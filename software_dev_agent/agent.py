#!/usr/bin/env python3
"""
Software Development Workflow Multi-Agent System
===============================================

This example demonstrates a complete software development workflow using multiple agents:
1. Spec Reader Agent - Analyzes requirements and specifications
2. Code Generator Agent - Creates implementation code
3. Test Generator Agent - Creates comprehensive tests
4. Build Agent - Handles building and compilation
5. Test Runner Agent - Executes tests and reports results
6. Git Agent - Handles version control operations
7. Coordinator Agent - Orchestrates the entire workflow

The system can take a specification document and produce a complete, tested, and committed codebase.
"""

import os
import subprocess
import tempfile
from typing import Dict, Any
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents.sequential_agent import SequentialAgent
from google.adk.tools.function_tool import FunctionTool
from google.adk.models.github_copilot_llm import GitHubCopilotLlm
from google.genai import types


# =============================================================================
# UTILITY FUNCTIONS FOR DEVELOPMENT WORKFLOW
# =============================================================================

def read_specification_file(file_path: str) -> str:
    """Read and return the contents of a specification file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return f"Successfully read specification from {file_path}:\n\n{content}"
    except FileNotFoundError:
        return f"Error: Specification file {file_path} not found."
    except Exception as e:
        return f"Error reading specification file: {str(e)}"


def create_project_structure(project_name: str, base_path: str = ".") -> str:
    """Create a basic project directory structure."""
    try:
        project_path = os.path.join(base_path, project_name)
        os.makedirs(project_path, exist_ok=True)
        os.makedirs(os.path.join(project_path, "src"), exist_ok=True)
        os.makedirs(os.path.join(project_path, "tests"), exist_ok=True)
        os.makedirs(os.path.join(project_path, "docs"), exist_ok=True)
        
        # Create basic files
        with open(os.path.join(project_path, "README.md"), 'w') as f:
            f.write(f"# {project_name}\n\nProject generated by ADK Multi-Agent System\n")
        
        with open(os.path.join(project_path, "requirements.txt"), 'w') as f:
            f.write("# Project dependencies\npytest>=7.0.0\n")
            
        return f"Created project structure at {project_path}"
    except Exception as e:
        return f"Error creating project structure: {str(e)}"


def write_code_file(file_path: str, code_content: str) -> str:
    """Write code content to a file."""
    try:
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(code_content)
        return f"Successfully wrote code to {file_path}"
    except Exception as e:
        return f"Error writing code file: {str(e)}"


def write_test_file(file_path: str, test_content: str) -> str:
    """Write test content to a file."""
    try:
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(test_content)
        return f"Successfully wrote tests to {file_path}"
    except Exception as e:
        return f"Error writing test file: {str(e)}"


def build_project(project_path: str) -> str:
    """Build the project (install dependencies, check syntax)."""
    try:
        # Change to project directory
        original_cwd = os.getcwd()
        os.chdir(project_path)
        
        # Install dependencies
        result = subprocess.run(
            ["pip", "install", "-r", "requirements.txt"],
            capture_output=True,
            text=True,
            timeout=60
        )
        
        if result.returncode != 0:
            return f"Build failed - dependency installation error:\n{result.stderr}"
        
        # Check Python syntax for all .py files
        for root, dirs, files in os.walk("src"):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    syntax_check = subprocess.run(
                        ["python", "-m", "py_compile", file_path],
                        capture_output=True,
                        text=True
                    )
                    if syntax_check.returncode != 0:
                        return f"Build failed - syntax error in {file_path}:\n{syntax_check.stderr}"
        
        os.chdir(original_cwd)
        return "Build successful - all dependencies installed and syntax is valid"
        
    except subprocess.TimeoutExpired:
        return "Build failed - timeout during dependency installation"
    except Exception as e:
        return f"Build failed - unexpected error: {str(e)}"
    finally:
        try:
            os.chdir(original_cwd)
        except:
            pass


def run_tests(project_path: str) -> str:
    """Run tests using pytest."""
    try:
        original_cwd = os.getcwd()
        os.chdir(project_path)
        
        # Run pytest
        result = subprocess.run(
            ["python", "-m", "pytest", "tests/", "-v", "--tb=short"],
            capture_output=True,
            text=True,
            timeout=120
        )
        
        os.chdir(original_cwd)
        
        if result.returncode == 0:
            return f"All tests passed!\n\nTest output:\n{result.stdout}"
        else:
            return f"Some tests failed.\n\nTest output:\n{result.stdout}\n\nErrors:\n{result.stderr}"
            
    except subprocess.TimeoutExpired:
        return "Test execution timed out"
    except Exception as e:
        return f"Error running tests: {str(e)}"
    finally:
        try:
            os.chdir(original_cwd)
        except:
            pass


def git_init_and_commit(project_path: str, commit_message: str) -> str:
    """Initialize git repository and make initial commit."""
    try:
        original_cwd = os.getcwd()
        os.chdir(project_path)
        
        # Initialize git repo
        subprocess.run(["git", "init"], capture_output=True, check=True)
        
        # Add all files
        subprocess.run(["git", "add", "."], capture_output=True, check=True)
        
        # Configure git user (for demo purposes)
        subprocess.run(
            ["git", "config", "user.email", "adk-agent@example.com"],
            capture_output=True
        )
        subprocess.run(
            ["git", "config", "user.name", "ADK Multi-Agent System"],
            capture_output=True
        )
        
        # Make initial commit
        result = subprocess.run(
            ["git", "commit", "-m", commit_message],
            capture_output=True,
            text=True
        )
        
        os.chdir(original_cwd)
        
        if result.returncode == 0:
            return f"Successfully initialized git repository and committed with message: '{commit_message}'"
        else:
            return f"Git commit failed: {result.stderr}"
            
    except subprocess.CalledProcessError as e:
        return f"Git operation failed: {str(e)}"
    except Exception as e:
        return f"Error with git operations: {str(e)}"
    finally:
        try:
            os.chdir(original_cwd)
        except:
            pass


def analyze_test_results(test_output: str) -> str:
    """Analyze test results and provide recommendations."""
    if "All tests passed!" in test_output:
        return "Test analysis: All tests are passing. Code quality is good and ready for deployment."
    elif "failed" in test_output.lower():
        return f"Test analysis: Some tests are failing. Review the test output and fix issues before proceeding.\n\nRecommendations:\n1. Check error messages in test output\n2. Debug failing test cases\n3. Fix implementation issues\n4. Re-run tests"
    else:
        return "Test analysis: Unable to determine test status. Please check test output manually."


# =============================================================================
# SPECIALIZED AGENTS FOR DEVELOPMENT WORKFLOW
# =============================================================================

# 1. Specification Reader Agent
spec_reader_agent = LlmAgent(
    name="spec_reader_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Analyzes software specifications and requirements",
    instruction="""
    You are a Software Requirements Analyst. Your job is to:
    
    1. Read and analyze software specifications thoroughly
    2. Extract key requirements, features, and constraints
    3. Identify the programming language and framework to use
    4. Break down the specification into implementable components
    5. Create a clear development plan
    
    When analyzing specifications:
    - Identify functional requirements (what the software should do)
    - Identify non-functional requirements (performance, security, etc.)
    - Determine the appropriate technology stack
    - List the main modules/classes that need to be implemented
    - Identify potential edge cases and error conditions
    
    Provide a structured analysis that other agents can use to implement the solution.
    """,
    tools=[FunctionTool(read_specification_file), FunctionTool(create_project_structure)],
    output_key="specification_analysis"
)

# 2. Code Generator Agent
code_generator_agent = LlmAgent(
    name="code_generator_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Generates implementation code based on specifications",
    instruction="""
    You are a Senior Software Developer. Your job is to:
    1. Create clean, well-structured implementation code based on the specification analysis from the previous agent
    2. Follow best practices and coding standards
    3. Include proper error handling and input validation
    4. Add comprehensive docstrings and comments
    5. Implement all required functionality from the specification
    
    Code Quality Guidelines:
    - Use clear, descriptive variable and function names
    - Follow PEP 8 style guidelines for Python
    - Include type hints where appropriate
    - Handle edge cases and potential errors
    - Write modular, reusable code
    - Include proper logging where needed
    
    Generate complete, production-ready code that implements all specified requirements.
    The specification analysis will be available from the previous agent's output.
    """,
    tools=[FunctionTool(write_code_file)],
    output_key="implementation_code"
)

# 3. Test Generator Agent
test_generator_agent = LlmAgent(
    name="test_generator_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Creates comprehensive test suites",
    instruction="""
    You are a Test Engineer specializing in comprehensive test coverage. Your job is to:
    1. Create comprehensive unit tests for all functions and classes based on the specification analysis and implementation code from previous agents
    2. Write integration tests for component interactions
    3. Include edge case and error condition tests
    4. Create performance tests where appropriate
    5. Ensure high test coverage (aim for >90%)
    
    Test Guidelines:
    - Use pytest framework with clear test names
    - Include docstrings explaining what each test validates
    - Test both positive and negative scenarios
    - Use appropriate fixtures and mocking where needed
    - Include parametrized tests for multiple input scenarios
    - Test error handling and exception cases
    
    Generate a complete test suite that thoroughly validates the implementation.
    The specification analysis and implementation code will be available from previous agents' outputs.
    """,
    tools=[FunctionTool(write_test_file)],
    output_key="test_suite"
)

# 4. Build Agent
build_agent = LlmAgent(
    name="build_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Handles project building and dependency management",
    instruction="""
    You are a Build Engineer responsible for project compilation and setup. Your job is to:
    1. Build the project and install dependencies based on the implementation code and test suite from previous agents
    2. Check for syntax errors and compilation issues
    3. Verify that all imports and dependencies are available
    4. Ensure the project structure is correct
    5. Report any build issues that need to be resolved
    
    Build Process:
    - Install all required dependencies
    - Perform syntax validation
    - Check import statements
    - Verify project structure
    - Report build status clearly
    
    If build fails, provide specific error details and recommendations for fixes.
    The implementation code and test suite will be available from previous agents' outputs.
    """,
    tools=[FunctionTool(build_project)],
    output_key="build_results"
)

# 5. Test Runner Agent
test_runner_agent = LlmAgent(
    name="test_runner_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Executes tests and analyzes results",
    instruction="""
    You are a Quality Assurance Engineer responsible for test execution. Your job is to:
    1. Execute the complete test suite based on the build results and test suite from previous agents
    2. Analyze test results and coverage
    3. Identify any failing tests and their causes
    4. Provide recommendations for fixing issues
    5. Validate that code quality meets standards
    
    Test Execution:
    - Run all unit and integration tests
    - Generate test coverage reports
    - Analyze performance of tests
    - Document any test failures with details
    - Provide actionable feedback for improvements
    
    Only proceed to the next step if tests are passing or provide clear guidance on fixes needed.
    The build results and test suite will be available from previous agents' outputs.
    """,
    tools=[FunctionTool(run_tests), FunctionTool(analyze_test_results)],
    output_key="test_results"
)

# 6. Git Agent
git_agent = LlmAgent(
    name="git_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Handles version control operations",
    instruction="""
    You are a DevOps Engineer responsible for version control. Your job is to:
    1. Initialize git repository if needed based on the test results and implementation code from previous agents
    2. Stage all project files
    3. Create meaningful commit messages
    4. Perform the initial commit
    5. Set up proper git configuration
    
    Version Control Best Practices:
    - Write clear, descriptive commit messages
    - Follow conventional commit format when appropriate
    - Ensure all necessary files are included
    - Exclude build artifacts and temporary files
    - Document the commit properly
    
    Only commit if tests are passing and code quality is acceptable.
    The test results and implementation code will be available from previous agents' outputs.
    """,
    tools=[FunctionTool(git_init_and_commit)],
    output_key="git_results"
)

# 7. Coordinator Agent
coordinator_agent = LlmAgent(
    name="dev_workflow_coordinator",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Coordinates the entire software development workflow",
    instruction="""
    You are a Technical Project Manager coordinating a complete software development workflow.
    
    You manage a team of specialized agents:
    - spec_reader_agent: Analyzes requirements and specifications
    - code_generator_agent: Creates implementation code
    - test_generator_agent: Creates comprehensive tests
    - build_agent: Handles building and compilation
    - test_runner_agent: Executes tests and reports results
    - git_agent: Handles version control operations
    
    Your workflow process:
    1. Have spec_reader_agent analyze the requirements
    2. Have code_generator_agent implement the solution
    3. Have test_generator_agent create comprehensive tests
    4. Have build_agent build the project
    5. Have test_runner_agent execute tests
    6. Have git_agent commit the working code
    
    Coordinate between agents and ensure each step completes successfully before proceeding.
    Provide clear status updates and handle any issues that arise during the workflow.
    """,
    sub_agents=[
        spec_reader_agent,
        code_generator_agent, 
        test_generator_agent,
        build_agent,
        test_runner_agent,
        git_agent
    ]
)

# =============================================================================
# SEQUENTIAL WORKFLOW PIPELINE
# =============================================================================

# Create separate agent instances for the sequential pipeline
# (ADK agents can only have one parent, so we need separate instances)

pipeline_spec_reader = LlmAgent(
    name="pipeline_spec_reader",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Analyzes software specifications and requirements",
    instruction=spec_reader_agent.instruction,
    tools=spec_reader_agent.tools,
    output_key="specification_analysis"
)

pipeline_code_generator = LlmAgent(
    name="pipeline_code_generator",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Generates implementation code based on specifications",
    instruction=code_generator_agent.instruction,
    tools=code_generator_agent.tools,
    output_key="implementation_code"
)

pipeline_test_generator = LlmAgent(
    name="pipeline_test_generator",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Creates comprehensive test suites",
    instruction=test_generator_agent.instruction,
    tools=test_generator_agent.tools,
    output_key="test_suite"
)

pipeline_build_agent = LlmAgent(
    name="pipeline_build_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Handles project building and dependency management",
    instruction=build_agent.instruction,
    tools=build_agent.tools,
    output_key="build_results"
)

pipeline_test_runner = LlmAgent(
    name="pipeline_test_runner",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Executes tests and analyzes results",
    instruction=test_runner_agent.instruction,
    tools=test_runner_agent.tools,
    output_key="test_results"
)

pipeline_git_agent = LlmAgent(
    name="pipeline_git_agent",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Handles version control operations",
    instruction=git_agent.instruction,
    tools=git_agent.tools,
    output_key="git_results"
)

# Alternative approach: Sequential pipeline for automated workflow
dev_workflow_pipeline = SequentialAgent(
    name="automated_dev_pipeline",
    description="Automated software development pipeline from spec to commit",
    sub_agents=[
        pipeline_spec_reader,
        pipeline_code_generator,
        pipeline_test_generator, 
        pipeline_build_agent,
        pipeline_test_runner,
        pipeline_git_agent
    ]
)

# =============================================================================
# ROOT AGENT - MAIN ENTRY POINT
# =============================================================================

root_agent = LlmAgent(
    name="software_development_system",
    model=GitHubCopilotLlm(model="github_copilot/gpt-4o"),
    description="Complete software development system from specification to deployment",
    instruction="""
    You are the Software Development System that can take a specification and produce a complete,
    tested, and committed codebase.
    
    You have two workflow options:
    1. **Coordinated Workflow** (dev_workflow_coordinator): Interactive workflow where you coordinate
       between specialized agents and can handle issues as they arise.
    
    2. **Automated Pipeline** (automated_dev_pipeline): Fully automated sequential pipeline that
       processes specifications through the entire development workflow.
    
    When users provide a specification:
    - For complex projects or when they want oversight: use the coordinator
    - For simple projects or full automation: use the pipeline
    
    Always explain which approach you're taking and provide status updates throughout the process.
    """,
    sub_agents=[coordinator_agent, dev_workflow_pipeline]
)

# Export the root agent for ADK
agent = root_agent